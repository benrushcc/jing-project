# Introduction to APT

在这个部分介绍APT的细节，APT是在编译期通过处理注解从而实现生成其他的源代码，资源等文件的一种手段

APT不能修改已有的源代码，只能生成新的源代码

目前有很多基于APT构建的库，都被广泛使用

# Introduction to Java module system
在这个部分介绍java9引入的module系统，以及module系统的现状，为什么要使用module系统进行封装

# APT 对比 Reflection

从APT生成的代码中，获取类的一些元信息，和反射是类似的，在这一块概念上，因为元数据通常都只需要被拿一次，后续不断的进行复用
因此两者可以看作完全没有差距

在方法调用层面，APT可以利用常量折叠的varhandle来让VM对其进行优化，获得和直接调用几乎完全一致的性能，且没有装箱拆箱的开销，并且生成
的代码天生具备更强的类型安全性，更不容易在运行时出现错误

APT需要增加build阶段的时间，但鉴于javac本来就很快，且增加的工作量并不大，这一点可以看作是完全可接受的

APT生成的代码完全属于java源代码的一部分，不需要在module-info中额外的处理，生成的类一般会和源码在同一个package里面
此时如果开发者选择对外暴露该类，那么生成的类也会一并被暴露出去，这符合APT的设计宗旨，而反射需要显式的open，提供额外的一层封装要求

APT生成的类需要在运行时有一套加载机制，这个需要库开发者提供一层额外的封装设计，比较常见的做法，也是jing项目使用的做法，是通过SPI进行动态的注册
关于这一点后续还会有更多的介绍

通过APT生成类的机制，对于debug阶段的开发有非常大的帮助，因为所有逻辑都是存在于源代码中的，直接可以用debug跑进去，能更好的理解代码运行的逻辑

# jing项目如何使用apt

首先jing-annprocessor是整个项目的元注解，他的作用是提供一个SPI的简易注册机制，通过一个@Provider注解，注解处理器会在扫描到这个注解之后，
在项目中生成一个jing-providers.json的文件，记录有哪些具体的SPI提供方

由于APT不允许注解处理器在编译期修改字节码，我们不能直接依赖APT来修改module-info的内容，将生成的实现通过SPI暴露出去，因此，编写了一个特定的
jing-maven-plugin，这个插件的作用是，检测到jing-providers.json的内容之后，修改module-info的字节码，把生成的实现也添加进去，这样就省去了用户自己写一遍provide with的麻烦事

@Provider的这一套机制是为了方便开发者将自己编写的类的细节通过SPI的机制提供给第三方库，省去了手动为生成类在module-info中还需要编写provide with的麻烦
可以更好的关注到自己的实现层面上，只需做好相应的maven配置即可

@Provider也可以作为一个偷懒的做法，用在非生成类的SPI提供方上面，利用这一套机制也可以实现服务方的暴露