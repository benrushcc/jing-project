# FFI documentation

这篇文档是有关于FFI机制的一个教学文档，是给不熟悉FFI概念的开发者了解什么是FFI，以及jing项目是如何配合FFI的机制来做封装设计的
读完这篇文档的读者应该对FFI有一个基本的认识，并且知道如何使用jing项目中提供的一些FFI基建去完成自己的功能集
FFI的全称是Foreign Function Interface，完整的定义可以参考 https://en.wikipedia.org/wiki/Foreign_function_interface
在接下来的文档中，FFI特指jing项目对于java22中推出的 [JEP 454: Foreign Function & Memory API](https://openjdk.org/jeps/454)
功能的整合，以提供更好的一套编程模型

# 基准声明

所有的源码和jep等内容的解读基于当前的LTS版本openjdk25的源码，和所有流行的系统一样，jdk在维持对外接口功能一致的基础上，内部的实现
可能会随着版本进行较大的变化，甚至是完全的重构，因此该文档的内容可能会随着后续jdk版本的变化而产生勘误，读者需要自行对其进行验证

# Heap vs Non-heap

堆内存是由GC托管的，开发者只需要通过new来进行申请而不需要手动释放
堆外内存可以被认为是不受GC托管，通过操作系统的API，或者是c标准库的malloc等函数进行分配的，需要自己管理内存的生命周期
当需要调用操作系统提供的系统调用，c标准库，或是其它动态库内的函数时，通常需要使用到堆外内存进行参数的传递与接收，这也是绝大多数情况下，开发者使用堆外内存的缘由

# 标准库的API： ByteBuffer

Bytebuffer设计的比较早，其内部结构比较复杂，读和写需要显式的切换状态，函数的语义不是很符合直觉：

```java
ByteBuffer buffer = ByteBuffer.allocateDirect(1024);
buffer.put(data);        // 写入数据
buffer.flip();           // 切换到读模式
byte b = buffer.get();   // 读取数据
buffer.clear();          // 切换到写模式
```

此外，ByteBuffer默认使用big endian，这和目前大多数机器采用的x86架构相反

关于堆外内存的抽象，jdk提供的ByteBuffer实现是DirectByteBuffer类，它是直接调用malloc申请的堆外内存，生命周期不确定，
依赖cleaner进行释放，不知道具体进行free的时机，这和许多第三方库的设计并不契合

# Project Panama带来的模型

Project Panama引入了memorysegment的模型，来替换之前的bytebuffer设计，同时做到对老系统的兼容，memorysegment可以很方便的转化为bytebuffer
引入了多种arena，开发者可以根据自己的需求来选择不同的内存生命周期
读写内存统一使用varhandle，函数调用统一使用methodhandle，堆内存和堆外内存的抽象转向为使用MemorySegment，使用Arena进行生命周期的绑定，整体实现了高度统一的设计

# JNI内部实现用的一些原理

这个地方讲一下jni的模型，包括静态编译和动态加载，如何允许和c层进行交互，函数绑定的机制之类的
jni是开发者在使用jni.h编写native函数，将其打包为动态库，然后放在java.library.path路径下，运行时通过在java层声明native函数，来进行动态的绑定和加载的一种机制
其内部原理也是调用了dlopen，在运行时加载动态库，然后查找动态库中所存在的函数指针，生成对应的调用stub，将其绑定到java的调用方法上去
可以通过jnienv拿到java层里面的函数与数据进行访问，需要结合java自身的异常体系进行处理，机制复杂，容易出错

# Panama downcall内部实现用的原理

panama的downcall和jni用的机制都是同一套，也是在运行时加载动态库，查找函数指针，然后绑定的一套流程，因此System.loadLibrary在panama的这一套里面也是可以复用的
不同的地方是，panama的API是分步骤的，更加透明化，查找到的函数指针是memorySegment类型，可以直接拿到函数在进程中的内存地址，然后将其绑定到具体的methodHandle上进行调用
动态库的生命周期也是用arena进行管理的，可以自己定制什么时候去卸载
实际开发中，很多操作都不需要通过jni在native层面操纵java层中的数据，panama也是直接省去了jni相关的函数，做更纯粹的第三方调用，整个系统的复杂度更低

# downcall可以使用到的一些option

讲解downcall里面可以用到的一些option，什么情况下该用这些option，哪些虽然jvm提供了，但是作为开发者不应该在项目中进行使用，会极大的增加维护难度

首先是critical，这个也是panama downcall里面最重要的一个option，在官方文档的说明里面，要求只有在极短时间的函数调用时，比如获取一个常量之类的，才推荐使用这个option
它可以降低downcall的开销，根据源码，主要是减少了一些线程状态迁移，栈整理，和做safepoint检查的开销

如果不知道是不是该在非常量的函数调用上使用critical，可以参考jvm内部是怎么做的，这是一种最保险的做法，在jvm的源码中也有很多涉及到内部JNI调用的机制，其中JVM_ENTRY宏可以
认为是普通的调用，JVM_LEAF对应的是critical的调用，如果第三方库实现的功能和标准库类似，可以看看vm有没有用JVM_LEAF来做调用的封装，比较典型的是malloc和free，这个在vm内部就是
用了JVM_LEAF进行封装，即使有时候malloc内部可能会涉及到系统调用，但vm依旧会把它归类到始终能很快完成的方法一类，并且尽可能的降低transition的开销，开发者可以以此基准来做简单的参考

在使用critical的时候可以结合使用allowHeap参数，这个笔者认为是一个鸡肋的功能，使用该参数的作用是降低堆内存和堆外内存之间互相拷贝的开销，通常只有数MB以上的内存在启用该选项后效果会
比较显著，但传递大内存到native函数中去，也就意味着要处理更大批量的数据，函数的调用时间也会随之增加，阻塞整体进入safepoint的时间，两者是相互制约的，很难想到有非常合适的应用场景
而且传递堆内存的时候，这一块内存是会显式的请求GC锁住的，在g1的实现里面是看一块region的pin
count来判断是否被锁住，整体开销不大，在zgc这种并发gc是原子变量配合锁的形式来实现的，要在全局做判断
这个选项和选用的gc关系密切，增加维护和调优的复杂度，不建议使用

firstVariadicArg可以选择链接可变参数的函数的时候，指定可变参数在函数绑定参数的位置，这个是用来调用像printf这类可变参数的函数时必须使用的选项，可变参数的函数在操作系统ABI中的调用约定
极有可能与普通函数不一致，需要单独的对待，事实上一个良好的FFI库不应该暴露任何使用可变参数的函数供其它语言调用，不建议使用

captureCallState可以将函数调用的一些状态给捕捉并返回，主要是用来接收errno等错误码的信息，这类错误码必须在函数调用之后立刻拿到，否则可能会被vm覆盖，笔者认为这个功能的出发点是很好的
方便用户在不编写wrapper库的情况下，很方便的调用操作系统API并拿到准确的错误码，之后根据文档进行相应的错误逻辑处理流程，但是其具体的实现对于开发者来说不太透明，在可以编写wrapper库的时候
这个功能不如自己手动的实现来的更加直观，更具备可维护性，因此也不建议使用

# Panama upcall的机制

这个地方只是简单的提一下upcall的原理，和c里面的通过函数指针实现回调的机制，upcall会把java函数产生出一个类似c的函数指针，供c进行调用
upcall最大的限制其实是传参问题，因为是从c层面做的传参，参数通常只能是数值类型，导致这个函数很难做一些复杂的逻辑，更多的是用来完成一些通知机制
比如某些C库可能只暴露回调的API设计，此时可以通过upcall，在回调函数中让其给java层的静态容器中，写入一些数据标记，然后java层就能对其进行感知之类的

在jing项目中，没有做upcall的相关设计，因为它会显著的增加复杂度

如果你要开发ffi的动态库（因为宏，内存管理，错误处理，以及兼容性相关的问题，你几乎总是需要自己编写一层c的wrapper），downcall几乎总是你最需要的核心功能
因为你会想要将主要的业务逻辑放在java，少量系统调用或高效算法实现等放在c层面

如果一个项目中同时存在downcall和upcall的使用，很容易会出现套娃的情况，任意一者就已经实现了round
trip了，结合使用只会让情况变得无比的复杂，和jni类似
upcall其实是更适合在c层面去实现，这样维护负担会小很多，java已经提供了很好的访问native内存的手段，在c的回调函数中写入内存，再到java层去读取，这个方式会好很多

# arena的实现源码解读，判断是否该在项目中进行使用

这部分的解读是基于jdk25的，后续内部实现可能会发生变化，不保证更新的及时，用户需要自己查看源码进行对照

先是arena.global的实现的讲解，直接就是没有任何的阻碍的一个访问,在这个版本里面，不会检查访问memorySegment的线程的所属性，不能关闭
默认情况下，通过FFI调用返回的指针类型都属于这类作用域，这个arena是拥有最好的访问性能的arena，如果不需要特定的生命周期管理，尽可能使用它

然后是arena.auto通过gc兜底的一个实现，走的是cleaner的方式，创建出来的memorySegment对象在被GC时，会触发让cleaner调用其对应的堆外内存的
free，这个清理机制和DirectByteBuffer类似，都是托管给GC的，具有一定的不确定性，不推荐使用

arena.shared相当于内存共享的机制，多个线程都可以访问该块内存，但是线程安全性需要自己保证，vm会做很多检查，确保生命周期的一致性
如果可以的话还是推荐堆外内存只在线程本地用，线程间交互用java的juc基建，这个是最不容易出错的

最后是confined，本线程用的一个分配，其实内部封装的就是malloc，通过链表链接，这个是最推荐使用的一个arena，兼顾了安全性和性能

# jing项目的ffm实现

jing项目只使用downcall，不使用upcall，使用任何一者就已经完成了round trip，是完备的，没有必要再引入upcall来增加整体的复杂性
这个地方应该说，downcall，upcall在有自己编写wrapper的情况下，是只需要其一的，如果不编写wrapper，很难做到安全性

ffm的实现走的是定义接口，用注解生成对应的实现类，然后在运行时通过接口拿到实现类的方式，具体的做法可以参考APT部分

然后是option的取舍的部分，只提供了critical和constant两个option，以简化整个模型，其他的option前面也都提到了，不建议使用，会增加整个系统的复杂度

# jing项目的内存分配封装

讲一下操作系统内存分配的实际情况，各个内存库都是怎么做的，然后jing项目是如何针对扩容场景，如何用mmap的方式来做优化，
核心是现实世界里面没有最好的统一的内存分配方式，只能说用户越了解自己使用到的相关场景，越能针对自己的情况做出更好的管理方案

